/**
 * Island Build Plugins
 *
 * Bun.build plugins that handle island detection at compile time.
 * When compileJSX() processes a page, these plugins intercept .island.tsx
 * imports and replace them with lightweight marker stubs that call renderMarker().
 *
 * This is the key mechanism that makes island architecture work at build time:
 * instead of shipping the real island component into the page bundle, we swap it
 * for a stub that renders the island's SSR HTML wrapped in a <castro-island>
 * custom element for client-side hydration.
 *
 * Two plugins work together:
 * 1. islandMarkerPlugin — replaces island source with marker stub code
 * 2. castroExternalsPlugin — keeps Castro internals external so singletons
 *    (registry, island tracking) are shared across all compiled pages
 */

import { dirname, resolve } from "node:path";
import { getIslandId } from "../utils/ids.js";

// Absolute path to Castro internals for the generated code imports
const CASTRO_SRC = resolve(dirname(import.meta.path), "..");

/**
 * Generates the source code for a Marker Component.
 *
 * The generated code imports renderMarker() from marker.js and exports
 * a component function that delegates to it. This stub replaces the real
 * island source during page compilation.
 *
 * @param {string} islandId - The unique ID (e.g., "components/Counter.island.tsx")
 * @returns {string} JavaScript code that exports a marker component function
 */
function generateMarkerCode(islandId) {
	// Import the real marker implementation from marker.js
	// This keeps the logic in a real file that can be linted, debugged, and type-checked
	const MARKER_PATH = resolve(CASTRO_SRC, "islands/marker.js");

	// JSON.stringify ensures proper escaping of special chars in islandId
	return `
    import { renderMarker } from "${MARKER_PATH}";
    export default (props) => renderMarker(${JSON.stringify(islandId)}, props);
  `.trim();
}

/**
 * Plugin to replace .island.tsx imports with marker stub code.
 *
 * When Bun.build encounters an import like:
 *   import Counter from "./Counter.island.tsx"
 *
 * This plugin intercepts the load and returns generated code that calls
 * renderMarker() instead of the real component. The real component's SSR
 * module is pre-loaded in the registry and accessed synchronously during
 * renderToString() traversal.
 *
 * @type {Bun.BunPlugin}
 */
export const islandMarkerPlugin = {
	name: "island-marker",
	setup(build) {
		build.onLoad({ filter: /\.island\.[jt]sx$/ }, (args) => {
			const islandId = getIslandId(args.path);

			const code = generateMarkerCode(islandId);

			return {
				contents: code,
				loader: "js",
			};
		});
	},
};

/**
 * Plugin to skip bundling Castro internals during page compilation.
 *
 * The marker code (generated by islandMarkerPlugin) imports from Castro's
 * own source files using absolute paths. Without this plugin, Bun.build
 * would bundle those files into each page — giving each page its own copy
 * of the registry, breaking singleton state (island tracking, CSS injection).
 *
 * Marking them as external ensures the compiled page's `import` statements
 * resolve to the same in-memory modules as the build process itself.
 *
 * @type {Bun.BunPlugin}
 */
export const castroExternalsPlugin = {
	name: "castro-externals",

	setup(build) {
		build.onResolve({ filter: /.*/ }, (args) => {
			if (args.path.startsWith(CASTRO_SRC)) {
				return { path: args.path, external: true };
			}
		});
	},
};
