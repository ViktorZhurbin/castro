/**
 * Island Marker Components
 *
 * Replaces the old options.vnode hook approach. Instead of intercepting component
 * rendering at runtime, islands are detected at build time by their .island.tsx
 * file extension. The build plugin (in compile-jsx.js) swaps the import with a
 * marker component generated by createMarker().
 *
 * The marker component:
 * 1. Looks up the island in the registry (compiled SSR module + client JS path)
 * 2. SSR-renders the real component using the framework adapter
 * 3. Wraps the HTML in a <castro-island> custom element for client hydration
 * 4. Tracks which islands are used (for CSS injection)
 */

import { messages } from "../messages/index.js";
import { getAdapter } from "./adapter.js";
import { islands } from "./registry.js";

/**
 * @import { Directive } from "../types.d.ts"
 */

/** @type {Directive[]} */
const DIRECTIVES = ["lenin:awake", "comrade:visible", "no:pasaran"];

/** @type {Directive} */
const DEFAULT_DIRECTIVE = "comrade:visible";

// Per-page tracking of which islands are used (for CSS injection)
/** @type {Set<string>} */
let usedIslands = new Set();

/**
 * Reset tracking before rendering each page.
 * @returns {Set<string>} The fresh set (same reference used during render)
 */
export function resetUsedIslands() {
	usedIslands = new Set();
	return usedIslands;
}

/** @returns {Set<string>} */
export function getUsedIslands() {
	return usedIslands;
}

/**
 * Create a marker component for an island.
 *
 * Returns a component function that, when rendered during page SSR:
 * - Extracts hydration directives from props
 * - SSR-renders the real island component
 * - Returns a <castro-island> wrapper element
 *
 * @param {string} islandId - Stable ID from getIslandId()
 * @returns {Function} A component function with .islandId property
 */
export function createMarker(islandId) {
	/**
	 * Marker component — stands in for the real island during page rendering.
	 * @param {Record<string, unknown>} props
	 */
	function IslandMarker(props = {}) {
		const adapter = getAdapter();
		const island = islands.getIsland(islandId);

		if (!island) {
			throw new Error(messages.errors.islandNotFoundRegistry(islandId));
		}

		// Track usage for CSS injection
		usedIslands.add(islandId);

		// Extract and validate hydration directives from props
		const { directive, cleanProps } = processProps(props);

		// SSR the real island component using the adapter
		let ssrHtml = "";
		try {
			ssrHtml = adapter.renderComponentToString(
				island.ssrModule.default,
				cleanProps,
			);
		} catch (e) {
			const err = /** @type {Error} */ (e);
			console.error(messages.errors.islandRenderFailed(islandId, err.message));

			// Render inline error instead of crashing the build
			ssrHtml = `<div style="border:2px dashed #c41e3a;padding:1rem;color:#c41e3a;background:#fff0f0;font-family:monospace">Island "${islandId}" failed to render: ${err.message}</div>`;
		}

		// no:pasaran — static only, no hydration wrapper
		if (directive === "no:pasaran") {
			return adapter.createElement("div", adapter.rawHtmlProp(ssrHtml));
		}

		// Wrap in <castro-island> for client-side hydration
		return adapter.createElement("castro-island", {
			directive,
			import: island.publicJsPath,
			"data-props": JSON.stringify(cleanProps),
			...adapter.rawHtmlProp(ssrHtml),
		});
	}

	// Tag so the registry can identify this as an island (used in CSS tracking)
	IslandMarker.islandId = islandId;
	return IslandMarker;
}

/**
 * Extract and validate hydration directives from component props.
 *
 * @param {Record<string, unknown>} props
 * @returns {{ directive: Directive, cleanProps: Record<string, unknown> }}
 */
function processProps(props = {}) {
	const foundDirectives = DIRECTIVES.filter((d) => d in props);

	if (foundDirectives.length > 1) {
		throw new Error(
			messages.errors.multipleDirectives(foundDirectives.join(", ")),
		);
	}

	// Remove directives from props before passing to the component
	const cleanProps = { ...props };
	for (const d of foundDirectives) {
		delete cleanProps[d];
	}

	return {
		directive: foundDirectives[0] ?? DEFAULT_DIRECTIVE,
		cleanProps,
	};
}
