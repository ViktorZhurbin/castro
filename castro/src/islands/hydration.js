/**
 * Castro Island - Custom Element for Lazy Hydration
 *
 * This is the CLIENT-SIDE runtime that makes islands interactive.
 *
 * How it works:
 * 1. Server renders HTML like: <castro-island comrade:visible import="/components/counter.js">
 * 2. Browser loads this file and registers <castro-island> custom element
 * 3. When element connects to DOM, it checks the loading directive
 * 4. Waits for trigger (visibility, idle, etc.)
 * 5. Dynamically imports the component JS
 * 6. Calls the component's mounting function to hydrate
 *
 * The key: JavaScript is loaded on-demand, not upfront. Pages start
 * as pure HTML and progressively enhance when conditions are met.
 */

const ELEMENT_TAG = "castro-island";

class CastroIsland extends HTMLElement {
	constructor() {
		super();
		this._hydrated = false;
	}

	async connectedCallback() {
		// Only hydrate once
		if (this._hydrated) return;

		// Wait for trigger condition based on directive
		if (this.hasAttribute("comrade:visible")) {
			// Lazy load when scrolled into view
			await this.waitVisible();
		} else if (this.hasAttribute("lenin:awake")) {
			// Immediate hydration, no waiting
			// (fall through to hydrate())
		}

		// Load and mount component
		await this.hydrate();
	}

	/**
	 * Wait until element is visible in viewport
	 *
	 * Uses IntersectionObserver which is more efficient than scroll listeners.
	 * The browser natively tracks element visibility.
	 *
	 * @returns {Promise<void>}
	 */
	waitVisible() {
		return new Promise((resolve) => {
			const observer = new IntersectionObserver(
				(entries) => {
					if (entries[0].isIntersecting) {
						observer.disconnect();
						resolve();
					}
				},
				// rootMargin extends the viewport boundary: start loading 100px
				// before element enters viewport. Feels faster to the user.
				{ rootMargin: "100px" },
			);
			observer.observe(this);
		});
	}

	/**
	 * Hydrate the island - load JS and make it interactive
	 *
	 * "Hydration" means attaching JavaScript behavior to existing HTML.
	 * The HTML was rendered at build time, now we're making it interactive.
	 */
	async hydrate() {
		if (this._hydrated) return;

		this._hydrated = true;

		try {
			// Get the path from import="/components/counter.js" attribute
			const importPath = this.getAttribute("import");
			if (!importPath) {
				console.error(`${ELEMENT_TAG}: missing import attribute`);
				return;
			}

			// Dynamically import the compiled component bundle.
			// This import() call triggers a network request for the JS.
			const module = await import(importPath);

			// Target is the actual component element inside <castro-island>
			// e.g., <preact-counter data-count="0">
			const target = this.firstElementChild;

			// module.default is the mounting function generated by compiler.
			// It reads props from data-* attributes and calls framework hydrate().
			if (typeof module.default === "function" && target) {
				await module.default(target);
			} else {
				console.error(`${ELEMENT_TAG}: module must export mounting function`);
			}

			// Mark as ready (useful for CSS transitions or debugging)
			this.setAttribute("ready", "");
		} catch (err) {
			console.error(`${ELEMENT_TAG}: hydration failed`, err);
		}
	}
}

// Register custom element
if (!customElements.get(ELEMENT_TAG)) {
	customElements.define(ELEMENT_TAG, CastroIsland);
}
