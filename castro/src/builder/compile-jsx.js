import { dirname, resolve } from "node:path";
import { messages } from "../messages/index.js";
import { getModule } from "../utils/cache.js";
import { getIslandId } from "../utils/ids.js";

// Absolute path to Castro internals for the generated code imports
const CASTRO_SRC = resolve(dirname(import.meta.path), "..");

/**
 * Generates the source code for a Marker Component.
 *
 * @param {string} islandId - The unique ID (e.g., "src/islands/Counter.tsx")
 * @returns {string} JavaScript code that exports a marker component function
 */
function generateMarkerCode(islandId) {
	// Import the real marker implementation from marker.js
	// This keeps the logic in a real file that can be linted, debugged, and type-checked
	const MARKER_PATH = resolve(CASTRO_SRC, "islands/marker.js");

	// JSON.stringify ensures proper escaping of special chars in islandId
	return `
    import { renderMarker } from "${MARKER_PATH}";
    export default (props) => renderMarker(${JSON.stringify(islandId)}, props);
  `.trim();
}

/**
 * Plugin to replace .island.tsx imports with the Marker Code above
 * @type {Bun.BunPlugin}
 */
const islandMarkerPlugin = {
	name: "island-marker",
	setup(build) {
		build.onLoad({ filter: /\.island\.[jt]sx$/ }, (args) => {
			const islandId = getIslandId(args.path);

			const code = generateMarkerCode(islandId);

			return {
				contents: code,
				loader: "js",
			};
		});
	},
};

/**
 * Plugin to skip bundling Castro internals during page compilation.
 *
 * The marker code (generated by islandMarkerPlugin) imports from Castro's
 * own source files using absolute paths. Without this plugin, Bun.build
 * would bundle those files into each page — giving each page its own copy
 * of the registry, breaking singleton state (island tracking, CSS injection).
 *
 * Marking them as external ensures the compiled page's `import` statements
 * resolve to the same in-memory modules as the build process itself.
 *
 * @type {Bun.BunPlugin}
 */
const castroExternalsPlugin = {
	name: "castro-externals",

	setup(build) {
		build.onResolve({ filter: /.*/ }, (args) => {
			if (args.path.startsWith(CASTRO_SRC)) {
				return { path: args.path, external: true };
			}
		});
	},
};

/**
 * Compile JSX/TSX to JavaScript and import the module
 *
 * Also extracts any imported CSS files for injection.
 * Uses the island-marker plugin to replace island imports with marker components.
 *
 * @param {string} sourcePath - Path to JSX/TSX file
 */
export async function compileJSX(sourcePath) {
	// Build configuration
	// Bun.build requires absolute entrypoints when using onResolve plugins
	const absoluteSourcePath = resolve(sourcePath);

	const result = await Bun.build({
		entrypoints: [absoluteSourcePath],
		target: "bun",
		packages: "external",
		format: "esm",
		// Pages and layouts compile to Preact VNodes (not HTML strings directly).
		// The final renderToString() call in render-page.js converts the complete
		// VNode tree to HTML in one pass. This is a build-time convenience —
		// Preact is NOT shipped to the browser for static pages.
		jsx: { runtime: "automatic", importSource: "preact" },
		loader: {
			".css": "css",
		},
		define: {
			// makes sure we use production mode for SSG
			"process.env.NODE_ENV": JSON.stringify("production"),
		},
		plugins: [castroExternalsPlugin, islandMarkerPlugin],
	});

	if (!result.success) {
		const errors = result.logs.map((log) => log.message).join("\n");
		throw new Error(`Bundle failed for ${sourcePath}:\n${errors}`);
	}

	const jsFile = result.outputs.find((f) => f.path.endsWith(".js"));
	const cssFiles = result.outputs.filter((f) => f.path.endsWith(".css"));

	if (!jsFile) {
		throw new Error(messages.build.noJsOutput(sourcePath));
	}

	const jsText = await jsFile.text();

	return {
		module: await getModule(sourcePath, jsText),
		cssFiles,
	};
}
